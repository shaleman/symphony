// This file is auto generated by modelgen tool
// Do not edit this file manually

package contivModel

import (
	"errors"
	"net/http"
	"encoding/json"
	"github.com/gorilla/mux"
	log "github.com/Sirupsen/logrus"
)

type HttpApiFunc func(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error)

type App struct {
	Key		string
	AppName	string
	TenantName	string
	LinkSets	AppLinkSets		`json:"link-sets,omitempty"`
	Links	AppLinks		`json:"links,omitempty"`
}

type AppLinkSets struct {
	Services	[]AppServicesLinkSet		`json:"services,omitempty"`
}

type AppServicesLinkSet struct {
	Type	string
	Key		string
	service		*Service
}

type AppLinks struct {
	Tenant	AppTenantLink		`json:"tenant,omitempty"`
}

type AppTenantLink struct {
	Type	string
	Key		string
	tenant		*Tenant
}

type EndpointGroup struct {
	Key		string
	GroupName	string
	TenantName	string
	NetworkName	string
	Policies	[]string
	LinkSets	EndpointGroupLinkSets		`json:"link-sets,omitempty"`
	Links	EndpointGroupLinks		`json:"links,omitempty"`
}

type EndpointGroupLinkSets struct {
	Services	[]EndpointGroupServicesLinkSet		`json:"services,omitempty"`
	Policies	[]EndpointGroupPoliciesLinkSet		`json:"policies,omitempty"`
}

type EndpointGroupServicesLinkSet struct {
	Type	string
	Key		string
	service		*Service
}

type EndpointGroupPoliciesLinkSet struct {
	Type	string
	Key		string
	policy		*Policy
}

type EndpointGroupLinks struct {
	Tenant	EndpointGroupTenantLink		`json:"tenant,omitempty"`
	Network	EndpointGroupNetworkLink		`json:"network,omitempty"`
}

type EndpointGroupTenantLink struct {
	Type	string
	Key		string
	tenant		*Tenant
}

type EndpointGroupNetworkLink struct {
	Type	string
	Key		string
	network		*Network
}

type Network struct {
	Key		string
	NetworkName	string
	TenantName	string
	IsPublic	bool
	IsPrivate	bool
	Encap	string
	Subnet	string
	Links	NetworkLinks		`json:"links,omitempty"`
}

type NetworkLinks struct {
	Tenant	NetworkTenantLink		`json:"tenant,omitempty"`
}

type NetworkTenantLink struct {
	Type	string
	Key		string
	tenant		*Tenant
}

type Policy struct {
	Key		string
	PolicyName	string
	TenantName	string
	Rules	[]string
	LinkSets	PolicyLinkSets		`json:"link-sets,omitempty"`
	Links	PolicyLinks		`json:"links,omitempty"`
}

type PolicyLinkSets struct {
	EndpointGroups	[]PolicyEndpointGroupsLinkSet		`json:"endpointGroups,omitempty"`
}

type PolicyEndpointGroupsLinkSet struct {
	Type	string
	Key		string
	endpointGroup		*EndpointGroup
}

type PolicyLinks struct {
	Tenant	PolicyTenantLink		`json:"tenant,omitempty"`
}

type PolicyTenantLink struct {
	Type	string
	Key		string
	tenant		*Tenant
}

type Service struct {
	Key		string
	Scale	int64
	Networks	[]string
	ServiceName	string
	AppName	string
	TenantName	string
	ImageName	string
	Cpu	int64
	Memory	string
	LinkSets	ServiceLinkSets		`json:"link-sets,omitempty"`
	Links	ServiceLinks		`json:"links,omitempty"`
}

type ServiceLinkSets struct {
	Networks	[]ServiceNetworksLinkSet		`json:"networks,omitempty"`
	Instances	[]ServiceInstancesLinkSet		`json:"instances,omitempty"`
}

type ServiceInstancesLinkSet struct {
	Type	string
	Key		string
	serviceInstance		*ServiceInstance
}

type ServiceNetworksLinkSet struct {
	Type	string
	Key		string
	network		*Network
}

type ServiceLinks struct {
	EndpointGroup	ServiceEndpointGroupLink		`json:"endpointGroup,omitempty"`
	Tenant	ServiceTenantLink		`json:"tenant,omitempty"`
	App	ServiceAppLink		`json:"app,omitempty"`
}

type ServiceTenantLink struct {
	Type	string
	Key		string
	tenant		*Tenant
}

type ServiceAppLink struct {
	Type	string
	Key		string
	app		*App
}

type ServiceEndpointGroupLink struct {
	Type	string
	Key		string
	endpointGroup		*EndpointGroup
}

type ServiceInstance struct {
	Key		string
	InstanceID	string
	TenantName	string
	AppName	string
	ServiceName	string
	Volumes	[]string
	LinkSets	ServiceInstanceLinkSets		`json:"link-sets,omitempty"`
	Links	ServiceInstanceLinks		`json:"links,omitempty"`
}

type ServiceInstanceLinkSets struct {
	Volumes	[]ServiceInstanceVolumesLinkSet		`json:"volumes,omitempty"`
}

type ServiceInstanceVolumesLinkSet struct {
	Type	string
	Key		string
	volume		*Volume
}

type ServiceInstanceLinks struct {
	Tenant	ServiceInstanceTenantLink		`json:"tenant,omitempty"`
	Services	ServiceInstanceServicesLink		`json:"services,omitempty"`
}

type ServiceInstanceTenantLink struct {
	Type	string
	Key		string
	tenant		*Tenant
}

type ServiceInstanceServicesLink struct {
	Type	string
	Key		string
	service		*Service
}

type Tenant struct {
	Key		string
	Name	string
	LinkSets	TenantLinkSets		`json:"link-sets,omitempty"`
}

type TenantLinkSets struct {
	Networks	[]TenantNetworksLinkSet		`json:"networks,omitempty"`
	Apps	[]TenantAppsLinkSet		`json:"apps,omitempty"`
	EndpointGroups	[]TenantEndpointGroupsLinkSet		`json:"endpointGroups,omitempty"`
	Policies	[]TenantPoliciesLinkSet		`json:"policies,omitempty"`
	Volumes	[]TenantVolumesLinkSet		`json:"volumes,omitempty"`
}

type TenantPoliciesLinkSet struct {
	Type	string
	Key		string
	policy		*Policy
}

type TenantVolumesLinkSet struct {
	Type	string
	Key		string
	volume		*Volume
}

type TenantNetworksLinkSet struct {
	Type	string
	Key		string
	network		*Network
}

type TenantAppsLinkSet struct {
	Type	string
	Key		string
	app		*App
}

type TenantEndpointGroupsLinkSet struct {
	Type	string
	Key		string
	endpointGroup		*EndpointGroup
}

type Volume struct {
	Key		string
	VolumeName	string
	TenantName	string
	Size	string
	LinkSets	VolumeLinkSets		`json:"link-sets,omitempty"`
	Links	VolumeLinks		`json:"links,omitempty"`
}

type VolumeLinkSets struct {
	ServiceInstances	[]VolumeServiceInstancesLinkSet		`json:"serviceInstances,omitempty"`
}

type VolumeServiceInstancesLinkSet struct {
	Type	string
	Key		string
	serviceInstance		*ServiceInstance
}

type VolumeLinks struct {
	Tenant	VolumeTenantLink		`json:"tenant,omitempty"`
}

type VolumeTenantLink struct {
	Type	string
	Key		string
	tenant		*Tenant
}



type Collections struct {
	apps    map[string]*App
	endpointGroups    map[string]*EndpointGroup
	networks    map[string]*Network
	policys    map[string]*Policy
	services    map[string]*Service
	serviceInstances    map[string]*ServiceInstance
	tenants    map[string]*Tenant
	volumes    map[string]*Volume
}

var collections Collections

type Callbacks interface {
	AppCreate(app *App) error
	AppDelete(app *App) error
	EndpointGroupCreate(endpointGroup *EndpointGroup) error
	EndpointGroupDelete(endpointGroup *EndpointGroup) error
	NetworkCreate(network *Network) error
	NetworkDelete(network *Network) error
	PolicyCreate(policy *Policy) error
	PolicyDelete(policy *Policy) error
	ServiceCreate(service *Service) error
	ServiceDelete(service *Service) error
	ServiceInstanceCreate(serviceInstance *ServiceInstance) error
	ServiceInstanceDelete(serviceInstance *ServiceInstance) error
	TenantCreate(tenant *Tenant) error
	TenantDelete(tenant *Tenant) error
	VolumeCreate(volume *Volume) error
	VolumeDelete(volume *Volume) error
}

var objCallbackHandler Callbacks


func Init(handler Callbacks) {
objCallbackHandler = handler

	collections.apps = make(map[string]*App)
	collections.endpointGroups = make(map[string]*EndpointGroup)
	collections.networks = make(map[string]*Network)
	collections.policys = make(map[string]*Policy)
	collections.services = make(map[string]*Service)
	collections.serviceInstances = make(map[string]*ServiceInstance)
	collections.tenants = make(map[string]*Tenant)
	collections.volumes = make(map[string]*Volume)
}


// Simple Wrapper for http handlers
func makeHttpHandler(handlerFunc HttpApiFunc) http.HandlerFunc {
	// Create a closure and return an anonymous function
	return func(w http.ResponseWriter, r *http.Request) {
		// Call the handler
		resp, err := handlerFunc(w, r, mux.Vars(r))
		if err != nil {
			// Log error
			log.Errorf("Handler for %!s(MISSING) %!s(MISSING) returned error: %!s(MISSING)", r.Method, r.URL, err)

			// Send HTTP response
			http.Error(w, err.Error(), http.StatusInternalServerError)
		} else {
			// Send HTTP response as Json
			err = writeJSON(w, http.StatusOK, resp)
			if err != nil {
				log.Errorf("Error generating json. Err: %!v(MISSING)", err)
			}
		}
	}
}

// writeJSON: writes the value v to the http response stream as json with standard
// json encoding.
func writeJSON(w http.ResponseWriter, code int, v interface{}) error {
	// Set content type as json
	w.Header().Set("Content-Type", "application/json")

	// write the HTTP status code
	w.WriteHeader(code)

	// Write the Json output
	return json.NewEncoder(w).Encode(v)
}

// Add all routes for REST handlers
func AddRoutes(router *mux.Router) {
	var route, listRoute string

	// Register app
	route = "/api/apps/{key}/"
	listRoute = "/api/apps/"
	log.Infof("Registering %s", route)
	router.Path(listRoute).Methods("GET").HandlerFunc(makeHttpHandler(httpListApps))
	router.Path(route).Methods("GET").HandlerFunc(makeHttpHandler(httpGetApp))
	router.Path(route).Methods("POST").HandlerFunc(makeHttpHandler(httpCreateApp))
	router.Path(route).Methods("PUT").HandlerFunc(makeHttpHandler(httpCreateApp))
	router.Path(route).Methods("DELETE").HandlerFunc(makeHttpHandler(httpDeleteApp))

	// Register endpointGroup
	route = "/api/endpointGroups/{key}/"
	listRoute = "/api/endpointGroups/"
	log.Infof("Registering %s", route)
	router.Path(listRoute).Methods("GET").HandlerFunc(makeHttpHandler(httpListEndpointGroups))
	router.Path(route).Methods("GET").HandlerFunc(makeHttpHandler(httpGetEndpointGroup))
	router.Path(route).Methods("POST").HandlerFunc(makeHttpHandler(httpCreateEndpointGroup))
	router.Path(route).Methods("PUT").HandlerFunc(makeHttpHandler(httpCreateEndpointGroup))
	router.Path(route).Methods("DELETE").HandlerFunc(makeHttpHandler(httpDeleteEndpointGroup))

	// Register network
	route = "/api/networks/{key}/"
	listRoute = "/api/networks/"
	log.Infof("Registering %s", route)
	router.Path(listRoute).Methods("GET").HandlerFunc(makeHttpHandler(httpListNetworks))
	router.Path(route).Methods("GET").HandlerFunc(makeHttpHandler(httpGetNetwork))
	router.Path(route).Methods("POST").HandlerFunc(makeHttpHandler(httpCreateNetwork))
	router.Path(route).Methods("PUT").HandlerFunc(makeHttpHandler(httpCreateNetwork))
	router.Path(route).Methods("DELETE").HandlerFunc(makeHttpHandler(httpDeleteNetwork))

	// Register policy
	route = "/api/policys/{key}/"
	listRoute = "/api/policys/"
	log.Infof("Registering %s", route)
	router.Path(listRoute).Methods("GET").HandlerFunc(makeHttpHandler(httpListPolicys))
	router.Path(route).Methods("GET").HandlerFunc(makeHttpHandler(httpGetPolicy))
	router.Path(route).Methods("POST").HandlerFunc(makeHttpHandler(httpCreatePolicy))
	router.Path(route).Methods("PUT").HandlerFunc(makeHttpHandler(httpCreatePolicy))
	router.Path(route).Methods("DELETE").HandlerFunc(makeHttpHandler(httpDeletePolicy))

	// Register service
	route = "/api/services/{key}/"
	listRoute = "/api/services/"
	log.Infof("Registering %s", route)
	router.Path(listRoute).Methods("GET").HandlerFunc(makeHttpHandler(httpListServices))
	router.Path(route).Methods("GET").HandlerFunc(makeHttpHandler(httpGetService))
	router.Path(route).Methods("POST").HandlerFunc(makeHttpHandler(httpCreateService))
	router.Path(route).Methods("PUT").HandlerFunc(makeHttpHandler(httpCreateService))
	router.Path(route).Methods("DELETE").HandlerFunc(makeHttpHandler(httpDeleteService))

	// Register serviceInstance
	route = "/api/serviceInstances/{key}/"
	listRoute = "/api/serviceInstances/"
	log.Infof("Registering %s", route)
	router.Path(listRoute).Methods("GET").HandlerFunc(makeHttpHandler(httpListServiceInstances))
	router.Path(route).Methods("GET").HandlerFunc(makeHttpHandler(httpGetServiceInstance))
	router.Path(route).Methods("POST").HandlerFunc(makeHttpHandler(httpCreateServiceInstance))
	router.Path(route).Methods("PUT").HandlerFunc(makeHttpHandler(httpCreateServiceInstance))
	router.Path(route).Methods("DELETE").HandlerFunc(makeHttpHandler(httpDeleteServiceInstance))

	// Register tenant
	route = "/api/tenants/{key}/"
	listRoute = "/api/tenants/"
	log.Infof("Registering %s", route)
	router.Path(listRoute).Methods("GET").HandlerFunc(makeHttpHandler(httpListTenants))
	router.Path(route).Methods("GET").HandlerFunc(makeHttpHandler(httpGetTenant))
	router.Path(route).Methods("POST").HandlerFunc(makeHttpHandler(httpCreateTenant))
	router.Path(route).Methods("PUT").HandlerFunc(makeHttpHandler(httpCreateTenant))
	router.Path(route).Methods("DELETE").HandlerFunc(makeHttpHandler(httpDeleteTenant))

	// Register volume
	route = "/api/volumes/{key}/"
	listRoute = "/api/volumes/"
	log.Infof("Registering %s", route)
	router.Path(listRoute).Methods("GET").HandlerFunc(makeHttpHandler(httpListVolumes))
	router.Path(route).Methods("GET").HandlerFunc(makeHttpHandler(httpGetVolume))
	router.Path(route).Methods("POST").HandlerFunc(makeHttpHandler(httpCreateVolume))
	router.Path(route).Methods("PUT").HandlerFunc(makeHttpHandler(httpCreateVolume))
	router.Path(route).Methods("DELETE").HandlerFunc(makeHttpHandler(httpDeleteVolume))

}

// LIST REST call
func httpListApps(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpListApps: %+v", vars)

	var list []*App
	for _, obj := range collections.apps {
		list = append(list, obj)
	}

	// Return the list
	return list, nil
}

// GET REST call
func httpGetApp(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetApp: %+v", vars)

	key := vars["key"]

	obj := collections.apps[key]
	if obj == nil {
		log.Errorf("app %s not found", key)
		return nil, errors.New("app not found")
	}

	// Return the obj
	return obj, nil
}

// CREATE REST call
func httpCreateApp(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetApp: %+v", vars)

	var obj App
	key := vars["key"]

	// Get object from the request
	err := json.NewDecoder(r.Body).Decode(&obj)
	if err != nil {
		log.Errorf("Error decoding app create request. Err %v", err)
		return nil, err
	}

	// set the key
	obj.Key = key

	// Perform callback
	err = objCallbackHandler.AppCreate(&obj)
	if err != nil {
		log.Errorf("AppCreate retruned error for: %+v. Err: %v", obj, err)
		return nil, err
	}

	// save it
	collections.apps[key] = &obj

	// Return the obj
	return obj, nil
}

// DELETE rest call
func httpDeleteApp(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpDeleteApp: %+v", vars)

	key := vars["key"]

	obj := collections.apps[key]
	if obj == nil {
		log.Errorf("app %s not found", key)
		return nil, errors.New("app not found")
	}

	// set the key
	obj.Key = key

	// Perform callback
	err := objCallbackHandler.AppDelete(obj)
	if err != nil {
		log.Errorf("AppDelete retruned error for: %+v. Err: %v", obj, err)
		return nil, err
	}

	// delete it
	delete(collections.apps, key)

	// Return the obj
	return obj, nil
}

// LIST REST call
func httpListEndpointGroups(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpListEndpointGroups: %+v", vars)

	var list []*EndpointGroup
	for _, obj := range collections.endpointGroups {
		list = append(list, obj)
	}

	// Return the list
	return list, nil
}

// GET REST call
func httpGetEndpointGroup(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetEndpointGroup: %+v", vars)

	key := vars["key"]

	obj := collections.endpointGroups[key]
	if obj == nil {
		log.Errorf("endpointGroup %s not found", key)
		return nil, errors.New("endpointGroup not found")
	}

	// Return the obj
	return obj, nil
}

// CREATE REST call
func httpCreateEndpointGroup(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetEndpointGroup: %+v", vars)

	var obj EndpointGroup
	key := vars["key"]

	// Get object from the request
	err := json.NewDecoder(r.Body).Decode(&obj)
	if err != nil {
		log.Errorf("Error decoding endpointGroup create request. Err %v", err)
		return nil, err
	}

	// set the key
	obj.Key = key

	// Perform callback
	err = objCallbackHandler.EndpointGroupCreate(&obj)
	if err != nil {
		log.Errorf("EndpointGroupCreate retruned error for: %+v. Err: %v", obj, err)
		return nil, err
	}

	// save it
	collections.endpointGroups[key] = &obj

	// Return the obj
	return obj, nil
}

// DELETE rest call
func httpDeleteEndpointGroup(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpDeleteEndpointGroup: %+v", vars)

	key := vars["key"]

	obj := collections.endpointGroups[key]
	if obj == nil {
		log.Errorf("endpointGroup %s not found", key)
		return nil, errors.New("endpointGroup not found")
	}

	// set the key
	obj.Key = key

	// Perform callback
	err := objCallbackHandler.EndpointGroupDelete(obj)
	if err != nil {
		log.Errorf("EndpointGroupDelete retruned error for: %+v. Err: %v", obj, err)
		return nil, err
	}

	// delete it
	delete(collections.endpointGroups, key)

	// Return the obj
	return obj, nil
}

// LIST REST call
func httpListNetworks(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpListNetworks: %+v", vars)

	var list []*Network
	for _, obj := range collections.networks {
		list = append(list, obj)
	}

	// Return the list
	return list, nil
}

// GET REST call
func httpGetNetwork(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetNetwork: %+v", vars)

	key := vars["key"]

	obj := collections.networks[key]
	if obj == nil {
		log.Errorf("network %s not found", key)
		return nil, errors.New("network not found")
	}

	// Return the obj
	return obj, nil
}

// CREATE REST call
func httpCreateNetwork(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetNetwork: %+v", vars)

	var obj Network
	key := vars["key"]

	// Get object from the request
	err := json.NewDecoder(r.Body).Decode(&obj)
	if err != nil {
		log.Errorf("Error decoding network create request. Err %v", err)
		return nil, err
	}

	// set the key
	obj.Key = key

	// Perform callback
	err = objCallbackHandler.NetworkCreate(&obj)
	if err != nil {
		log.Errorf("NetworkCreate retruned error for: %+v. Err: %v", obj, err)
		return nil, err
	}

	// save it
	collections.networks[key] = &obj

	// Return the obj
	return obj, nil
}

// DELETE rest call
func httpDeleteNetwork(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpDeleteNetwork: %+v", vars)

	key := vars["key"]

	obj := collections.networks[key]
	if obj == nil {
		log.Errorf("network %s not found", key)
		return nil, errors.New("network not found")
	}

	// set the key
	obj.Key = key

	// Perform callback
	err := objCallbackHandler.NetworkDelete(obj)
	if err != nil {
		log.Errorf("NetworkDelete retruned error for: %+v. Err: %v", obj, err)
		return nil, err
	}

	// delete it
	delete(collections.networks, key)

	// Return the obj
	return obj, nil
}

// LIST REST call
func httpListPolicys(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpListPolicys: %+v", vars)

	var list []*Policy
	for _, obj := range collections.policys {
		list = append(list, obj)
	}

	// Return the list
	return list, nil
}

// GET REST call
func httpGetPolicy(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetPolicy: %+v", vars)

	key := vars["key"]

	obj := collections.policys[key]
	if obj == nil {
		log.Errorf("policy %s not found", key)
		return nil, errors.New("policy not found")
	}

	// Return the obj
	return obj, nil
}

// CREATE REST call
func httpCreatePolicy(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetPolicy: %+v", vars)

	var obj Policy
	key := vars["key"]

	// Get object from the request
	err := json.NewDecoder(r.Body).Decode(&obj)
	if err != nil {
		log.Errorf("Error decoding policy create request. Err %v", err)
		return nil, err
	}

	// set the key
	obj.Key = key

	// Perform callback
	err = objCallbackHandler.PolicyCreate(&obj)
	if err != nil {
		log.Errorf("PolicyCreate retruned error for: %+v. Err: %v", obj, err)
		return nil, err
	}

	// save it
	collections.policys[key] = &obj

	// Return the obj
	return obj, nil
}

// DELETE rest call
func httpDeletePolicy(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpDeletePolicy: %+v", vars)

	key := vars["key"]

	obj := collections.policys[key]
	if obj == nil {
		log.Errorf("policy %s not found", key)
		return nil, errors.New("policy not found")
	}

	// set the key
	obj.Key = key

	// Perform callback
	err := objCallbackHandler.PolicyDelete(obj)
	if err != nil {
		log.Errorf("PolicyDelete retruned error for: %+v. Err: %v", obj, err)
		return nil, err
	}

	// delete it
	delete(collections.policys, key)

	// Return the obj
	return obj, nil
}

// LIST REST call
func httpListServices(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpListServices: %+v", vars)

	var list []*Service
	for _, obj := range collections.services {
		list = append(list, obj)
	}

	// Return the list
	return list, nil
}

// GET REST call
func httpGetService(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetService: %+v", vars)

	key := vars["key"]

	obj := collections.services[key]
	if obj == nil {
		log.Errorf("service %s not found", key)
		return nil, errors.New("service not found")
	}

	// Return the obj
	return obj, nil
}

// CREATE REST call
func httpCreateService(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetService: %+v", vars)

	var obj Service
	key := vars["key"]

	// Get object from the request
	err := json.NewDecoder(r.Body).Decode(&obj)
	if err != nil {
		log.Errorf("Error decoding service create request. Err %v", err)
		return nil, err
	}

	// set the key
	obj.Key = key

	// Perform callback
	err = objCallbackHandler.ServiceCreate(&obj)
	if err != nil {
		log.Errorf("ServiceCreate retruned error for: %+v. Err: %v", obj, err)
		return nil, err
	}

	// save it
	collections.services[key] = &obj

	// Return the obj
	return obj, nil
}

// DELETE rest call
func httpDeleteService(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpDeleteService: %+v", vars)

	key := vars["key"]

	obj := collections.services[key]
	if obj == nil {
		log.Errorf("service %s not found", key)
		return nil, errors.New("service not found")
	}

	// set the key
	obj.Key = key

	// Perform callback
	err := objCallbackHandler.ServiceDelete(obj)
	if err != nil {
		log.Errorf("ServiceDelete retruned error for: %+v. Err: %v", obj, err)
		return nil, err
	}

	// delete it
	delete(collections.services, key)

	// Return the obj
	return obj, nil
}

// LIST REST call
func httpListServiceInstances(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpListServiceInstances: %+v", vars)

	var list []*ServiceInstance
	for _, obj := range collections.serviceInstances {
		list = append(list, obj)
	}

	// Return the list
	return list, nil
}

// GET REST call
func httpGetServiceInstance(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetServiceInstance: %+v", vars)

	key := vars["key"]

	obj := collections.serviceInstances[key]
	if obj == nil {
		log.Errorf("serviceInstance %s not found", key)
		return nil, errors.New("serviceInstance not found")
	}

	// Return the obj
	return obj, nil
}

// CREATE REST call
func httpCreateServiceInstance(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetServiceInstance: %+v", vars)

	var obj ServiceInstance
	key := vars["key"]

	// Get object from the request
	err := json.NewDecoder(r.Body).Decode(&obj)
	if err != nil {
		log.Errorf("Error decoding serviceInstance create request. Err %v", err)
		return nil, err
	}

	// set the key
	obj.Key = key

	// Perform callback
	err = objCallbackHandler.ServiceInstanceCreate(&obj)
	if err != nil {
		log.Errorf("ServiceInstanceCreate retruned error for: %+v. Err: %v", obj, err)
		return nil, err
	}

	// save it
	collections.serviceInstances[key] = &obj

	// Return the obj
	return obj, nil
}

// DELETE rest call
func httpDeleteServiceInstance(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpDeleteServiceInstance: %+v", vars)

	key := vars["key"]

	obj := collections.serviceInstances[key]
	if obj == nil {
		log.Errorf("serviceInstance %s not found", key)
		return nil, errors.New("serviceInstance not found")
	}

	// set the key
	obj.Key = key

	// Perform callback
	err := objCallbackHandler.ServiceInstanceDelete(obj)
	if err != nil {
		log.Errorf("ServiceInstanceDelete retruned error for: %+v. Err: %v", obj, err)
		return nil, err
	}

	// delete it
	delete(collections.serviceInstances, key)

	// Return the obj
	return obj, nil
}

// LIST REST call
func httpListTenants(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpListTenants: %+v", vars)

	var list []*Tenant
	for _, obj := range collections.tenants {
		list = append(list, obj)
	}

	// Return the list
	return list, nil
}

// GET REST call
func httpGetTenant(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetTenant: %+v", vars)

	key := vars["key"]

	obj := collections.tenants[key]
	if obj == nil {
		log.Errorf("tenant %s not found", key)
		return nil, errors.New("tenant not found")
	}

	// Return the obj
	return obj, nil
}

// CREATE REST call
func httpCreateTenant(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetTenant: %+v", vars)

	var obj Tenant
	key := vars["key"]

	// Get object from the request
	err := json.NewDecoder(r.Body).Decode(&obj)
	if err != nil {
		log.Errorf("Error decoding tenant create request. Err %v", err)
		return nil, err
	}

	// set the key
	obj.Key = key

	// Perform callback
	err = objCallbackHandler.TenantCreate(&obj)
	if err != nil {
		log.Errorf("TenantCreate retruned error for: %+v. Err: %v", obj, err)
		return nil, err
	}

	// save it
	collections.tenants[key] = &obj

	// Return the obj
	return obj, nil
}

// DELETE rest call
func httpDeleteTenant(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpDeleteTenant: %+v", vars)

	key := vars["key"]

	obj := collections.tenants[key]
	if obj == nil {
		log.Errorf("tenant %s not found", key)
		return nil, errors.New("tenant not found")
	}

	// set the key
	obj.Key = key

	// Perform callback
	err := objCallbackHandler.TenantDelete(obj)
	if err != nil {
		log.Errorf("TenantDelete retruned error for: %+v. Err: %v", obj, err)
		return nil, err
	}

	// delete it
	delete(collections.tenants, key)

	// Return the obj
	return obj, nil
}

// LIST REST call
func httpListVolumes(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpListVolumes: %+v", vars)

	var list []*Volume
	for _, obj := range collections.volumes {
		list = append(list, obj)
	}

	// Return the list
	return list, nil
}

// GET REST call
func httpGetVolume(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetVolume: %+v", vars)

	key := vars["key"]

	obj := collections.volumes[key]
	if obj == nil {
		log.Errorf("volume %s not found", key)
		return nil, errors.New("volume not found")
	}

	// Return the obj
	return obj, nil
}

// CREATE REST call
func httpCreateVolume(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGetVolume: %+v", vars)

	var obj Volume
	key := vars["key"]

	// Get object from the request
	err := json.NewDecoder(r.Body).Decode(&obj)
	if err != nil {
		log.Errorf("Error decoding volume create request. Err %v", err)
		return nil, err
	}

	// set the key
	obj.Key = key

	// Perform callback
	err = objCallbackHandler.VolumeCreate(&obj)
	if err != nil {
		log.Errorf("VolumeCreate retruned error for: %+v. Err: %v", obj, err)
		return nil, err
	}

	// save it
	collections.volumes[key] = &obj

	// Return the obj
	return obj, nil
}

// DELETE rest call
func httpDeleteVolume(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpDeleteVolume: %+v", vars)

	key := vars["key"]

	obj := collections.volumes[key]
	if obj == nil {
		log.Errorf("volume %s not found", key)
		return nil, errors.New("volume not found")
	}

	// set the key
	obj.Key = key

	// Perform callback
	err := objCallbackHandler.VolumeDelete(obj)
	if err != nil {
		log.Errorf("VolumeDelete retruned error for: %+v. Err: %v", obj, err)
		return nil, err
	}

	// delete it
	delete(collections.volumes, key)

	// Return the obj
	return obj, nil
}

